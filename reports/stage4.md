### Результаты профилирования

Был изменён способ вычисления хэшкода, и теперь видно, что проксирование действительно работает. Судя по логам, распределение по трём нодам примерно равномерное.
По представленным ниже графикам можно сказать, что добавление шардирования по большей части сказалось на памяти, нежели на cpu. Добавилось хранение мапы с узлами топологии и клиентами, метод invoke() при изменении alloc захватывает 20-35%, а для cpu меньше 10%.

**Обстрел put-ами**
Параметры: -t64 -c64 -R6000
```
   Thread Stats   Avg      Stdev     Max   +/- Stdev
     Latency     1.72ms  782.49us  10.36ms   66.64%
     Req/Sec    99.23     47.65   222.00     79.29%
   Latency Distribution (HdrHistogram - Recorded Latency)
  50.000%    1.62ms
  75.000%    2.23ms
  90.000%    2.82ms
  99.000%    3.68ms
  99.900%    4.38ms
  99.990%    6.37ms
  99.999%    8.98ms
 100.000%   10.37ms
 ----------------------------------------------------------
   540046 requests in 1.50m, 42.76MB read
 Requests/sec:   6000.68
 Transfer/sec:    486.56KB
```
6000 запроса в секунду при обещанных 6000. Пришлось снизить, потому что при -R7000 выдерживает только ~6100

Для наглядности добавлю Latency с 3 этапа:
```
  Latency Distribution (HdrHistogram - Recorded Latency)
 50.000%    1.53ms
 75.000%    2.02ms
 90.000%    2.44ms
 99.000%    3.01ms
 99.900%    3.36ms
 99.990%    6.18ms
 99.999%    8.53ms
100.000%    9.56ms
```
Время выполнения запросов увеличилось процентов на 10%. Увеличение произошло из-за того, что для каждого запроса добавляется время на вычисление хэшкодов, а к трети запросов время на invoke() реквеста на другой узел.

ALLOC
3% - Отправка респонса
9% - Put в DAO
19% - Выяснение ноды по ключу, murmur хэширование
30% - Чтение из сокетов
39% - Проксирование
[ALLOC PUT](profiling_results/allocput4.svg)

CPU
2% - Usert в DAO
8% - Проксирование
14% - Отправка ответа HttpSession.sendResponse
17% - Чтение реквестов
24% - Потоки-workerы берут задачи из очереди
31% - Опрос состояния сокетов
[CPU PUT](profiling_results/cpuput4.svg)

LOCK
55% - Потоки-workerы складывают в очередь задачи
36% - Потоки-workerы берут задачи из очереди
10% - Отправка ответа HttpSession.sendResponse
[LOCK PUT](profiling_results/lockput4.svg)

Обстрел get-ами
Параметры: -t64 -c64 -R6000
```
   Thread Stats   Avg      Stdev     Max   +/- Stdev
     Latency     1.76ms  780.25us   7.94ms   66.27%
     Req/Sec    99.25     47.18   222.00     79.67%
   Latency Distribution (HdrHistogram - Recorded Latency)
  50.000%    1.66ms
  75.000%    2.28ms
  90.000%    2.86ms
  99.000%    3.69ms
  99.900%    4.28ms
  99.990%    5.06ms
  99.999%    6.35ms
 100.000%    7.94ms
 ----------------------------------------------------------
   540038 requests in 1.50m, 44.75MB read
 Requests/sec:   6000.67
 Transfer/sec:    509.23KB
```
6000 requests/sec из 6000 обещанных. Больше 6000 на get тоже не выдерживает.

Latency 3 стадии:
```
 Latency Distribution (HdrHistogram - Recorded Latency)
 50.000%    1.16ms
 75.000%    1.59ms
 90.000%    2.03ms
 99.000%    2.72ms
 99.900%    3.04ms
 99.990%    3.43ms
 99.999%    5.84ms
100.000%    7.86ms
```
 До 99,99% время ответа возрасло на ~40%. Для get разница во времени сильно больше, чем для put, хотя proxy() и хэширование работает и для того, и для того. Причиной такой разницы может быть то, что для get, в отличие от put, нужно отправлять непустое body с найденным ключом, а за счёт проксирования это делается дважды.

ALLOC
1% - Потоки-workerы берут задачи из очереди
3% - Отправка ответа HttpSession.sendResponse
14% - Выяснение ноды по ключу, murmur хэширование
19% - Get из dao
24% - Проксирование
38% - Чтение из сокетов
[ALLOC GET](profiling_results/allocget4.svg)

CPU
5% - Get из dao
7% - Проксирование
10% - Отправка ответа HttpSession.sendResponse
14% - Выяснение ноды по ключу, murmur хэширование
18% - Чтение из сокетов
24% - Потоки-workerы берут задачи из очереди
32% - Опрос состояния селекторов
[CPU GET](profiling_results/cpuget4.svg)

LOCK
22% - Потоки-workerы берут задачи из очереди
50% - Get в dao
25% - Потоки-workerы складывают в очередь задачи
[LOCK GET](profiling_results/lockget4.svg)